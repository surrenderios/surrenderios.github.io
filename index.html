<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Alex</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Alex">
<meta property="og:url" content="http://www.alexcocoa.com/index.html">
<meta property="og:site_name" content="Alex">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex">
  
    <link rel="alternative" href="/atom.xml" title="Alex" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/me.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Alex Wu</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/surrenderios" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/2439892130/home?wvr=5&lf=reg" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="http://blog.csdn.net/u012972257" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="mailto:surrenderios@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/u012972257">CSDN的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">什么都不要问，我什么都不会说的！</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Alex Wu</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/me.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Alex Wu</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/surrenderios" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/2439892130/home?wvr=5&lf=reg" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="http://blog.csdn.net/u012972257" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="mailto:surrenderios@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-AVFoundation-Play" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/20/AVFoundation-Play/" class="article-date">
  	<time datetime="2019-08-20T06:17:26.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/AVFoundation-Play/">AVFoundation_Play</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h1><p>播放控制的对象关系如图:</p>
<img src="/2019/08/20/AVFoundation-Play/avplayerLayer_2x.png">

<h3 id="AVPlayerItem"><a href="#AVPlayerItem" class="headerlink" title="AVPlayerItem"></a>AVPlayerItem</h3><p>使用 AVPlayerItem 来对 AVAsset 的播放状态进行控制</p>
<h3 id="AVPlayerItemTrack"><a href="#AVPlayerItemTrack" class="headerlink" title="AVPlayerItemTrack"></a>AVPlayerItemTrack</h3><p>表示播放的 轨道 状态</p>
<h3 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h3><p>继承自 CALayer ，对播放的视频进行展示</p>
<h3 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h3><p>提供对单个 AVPlayerItem 的播放接口控制和的UI响应</p>
<h3 id="AVQueuePlayer"><a href="#AVQueuePlayer" class="headerlink" title="AVQueuePlayer"></a>AVQueuePlayer</h3><p>继承自AVPlayer，允许传入多个 AVPlayerItem，然后进行控制</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AVFoundation-AVAsset" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/20/AVFoundation-AVAsset/" class="article-date">
  	<time datetime="2019-08-20T06:17:15.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/AVFoundation-AVAsset/">AVFoundation_AVAsset</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AVAsset"><a href="#AVAsset" class="headerlink" title="AVAsset"></a>AVAsset</h1><p>AVAsset 是对资源文件的一个描述, 可以是本地文件或者网络流。结构如下：</p>
<img src="/2019/08/20/AVFoundation-AVAsset/avassetHierarchy_2x.png">

<h1 id="AVURLAsset"><a href="#AVURLAsset" class="headerlink" title="AVURLAsset"></a>AVURLAsset</h1><p>继承自AVAsset，代表了一个本地文件或流文件的引用，可以通过该引用对内容进行访问，例如生成某一帧的图片，转换视频质量等</p>
<h1 id="AVFragmentedAsset"><a href="#AVFragmentedAsset" class="headerlink" title="AVFragmentedAsset"></a>AVFragmentedAsset</h1><p>继承自AVURLAsset, 可以在不改变之前数据结构的情况下，对 Asset 进行修改，支持MP4和QuickTime类型文件（iOS 12后支持）</p>
<p>在实际使用中, 一般都是会使用其子类 AVURLAsset，当对视频进行编辑时使用 AVComposition，</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AVFoundation" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/20/AVFoundation/" class="article-date">
  	<time datetime="2019-08-20T06:17:04.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/AVFoundation/">AVFoundation</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AVFoundation 是 iOS/Mac OS / Watch OS 系统用于处理视频音频的上层框架,  封装了底层对设备的软硬件控制。</p>
<p>在 iOS 中该框架的位置如下图:</p>
<img src="/2019/08/20/AVFoundation/3691932-3a17b0a605bdfa18.png">


<p>在 Mac OS 中该框架的位置如下图：</p>
<img src="/2019/08/20/AVFoundation/frameworksBlockDiagramOSX_2x.png">



      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AVFoundation-Time" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/20/AVFoundation-Time/" class="article-date">
  	<time datetime="2019-08-20T06:16:41.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/AVFoundation-Time/">AVFoundation_Time</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CMTime"><a href="#CMTime" class="headerlink" title="CMTime"></a>CMTime</h1><p>CMTime 是 CoreMedia 框架中的一个结构体，用来表示媒体的时间</p>
<h2 id="CMTimeRange"><a href="#CMTimeRange" class="headerlink" title="CMTimeRange"></a>CMTimeRange</h2><p>表示一个范围时间段</p>
<h2 id="AVTime"><a href="#AVTime" class="headerlink" title="AVTime"></a>AVTime</h2><p>对CMTime提供了 NSValue 和 NSCoder 的支持</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AVFoundation-Export" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/20/AVFoundation-Export/" class="article-date">
  	<time datetime="2019-08-20T06:10:49.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/AVFoundation-Export/">AVFoundation_Export</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><h2 id="AVAssetReader"><a href="#AVAssetReader" class="headerlink" title="AVAssetReader"></a>AVAssetReader</h2><p>提供从 AVAsset 获取 media 数据的服务</p>
<h2 id="AVAssetTrack"><a href="#AVAssetTrack" class="headerlink" title="AVAssetTrack"></a>AVAssetTrack</h2><p>从 AVAsset 中读取轨道信息</p>
<h2 id="AVAssetReaderOutput"><a href="#AVAssetReaderOutput" class="headerlink" title="AVAssetReaderOutput"></a>AVAssetReaderOutput</h2><p>一个定义从 AVAssetReader 读取样本数据的抽象类</p>
<h2 id="AVAssetReaderTrackOutput"><a href="#AVAssetReaderTrackOutput" class="headerlink" title="AVAssetReaderTrackOutput"></a>AVAssetReaderTrackOutput</h2><p>实现抽象类AVAssetReaderOutput，读取 AVAssetReader 的 asset 中的轨道数据</p>
<h2 id="AVAssetReaderAudioMixOutput"><a href="#AVAssetReaderAudioMixOutput" class="headerlink" title="AVAssetReaderAudioMixOutput"></a>AVAssetReaderAudioMixOutput</h2><p>实现抽象类AVAssetReaderOutput， 读取 AVAssetReader 的 asset 中的合成的音频数据</p>
<h2 id="AVAssetReaderVideoCompositionOutput"><a href="#AVAssetReaderVideoCompositionOutput" class="headerlink" title="AVAssetReaderVideoCompositionOutput"></a>AVAssetReaderVideoCompositionOutput</h2><p>实现抽象类AVAssetReaderOutput， 读取 AVAssetReader 的 asset 中的合成的视频数据</p>
<h2 id="AVAssetWriter"><a href="#AVAssetWriter" class="headerlink" title="AVAssetWriter"></a>AVAssetWriter</h2><p>提供写入 media 数据到新创建的 AVAsset 的服务</p>
<h2 id="AVAssetWriterInput"><a href="#AVAssetWriterInput" class="headerlink" title="AVAssetWriterInput"></a>AVAssetWriterInput</h2><p>一个输入 meida 数据给 AVAssetWriter 的勒</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AVFoundation-Capture" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/20/AVFoundation-Capture/" class="article-date">
  	<time datetime="2019-08-20T06:10:07.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/AVFoundation-Capture/">AVFoundation_Capture</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="拍摄"><a href="#拍摄" class="headerlink" title="拍摄"></a>拍摄</h1><h2 id="输入组件"><a href="#输入组件" class="headerlink" title="输入组件"></a><strong>输入组件</strong></h2><h2 id="AVCaptureDevice"><a href="#AVCaptureDevice" class="headerlink" title="AVCaptureDevice"></a>AVCaptureDevice</h2><p>物理输入设备, 例如摄像头或者麦克风等</p>
<h2 id="AVCaptureDeviceInputSource"><a href="#AVCaptureDeviceInputSource" class="headerlink" title="AVCaptureDeviceInputSource"></a>AVCaptureDeviceInputSource</h2><p>输入源设备的描述</p>
<h2 id="AVCaptureDeviceFormat"><a href="#AVCaptureDeviceFormat" class="headerlink" title="AVCaptureDeviceFormat"></a>AVCaptureDeviceFormat</h2><p>描述设备格式</p>
<h2 id="AVCaptureInput"><a href="#AVCaptureInput" class="headerlink" title="AVCaptureInput"></a>AVCaptureInput</h2><p>抽象类，连接输入源和AVCaptureSession</p>
<h2 id="AVCaptureInputPort"><a href="#AVCaptureInputPort" class="headerlink" title="AVCaptureInputPort"></a>AVCaptureInputPort</h2><p>提供视频流数据的描述，通过AVCaptureConnection来连接AVCaptureInput和AVCaptureOutput.</p>
<h2 id="AVCaptureDeviceInput"><a href="#AVCaptureDeviceInput" class="headerlink" title="AVCaptureDeviceInput"></a>AVCaptureDeviceInput</h2><p>实现使用设备作为输入源连接到AVCaptureSession</p>
<h2 id="AVCaptureScreenInput"><a href="#AVCaptureScreenInput" class="headerlink" title="AVCaptureScreenInput"></a>AVCaptureScreenInput</h2><p>实现使用屏幕作为输入源连接到AVCaptureSession</p>
<h1 id="连接组件"><a href="#连接组件" class="headerlink" title="连接组件"></a><strong>连接组件</strong></h1><p>##AVCaptureSession<br>AVFoundation中拍摄的中心组建，承接上下文</p>
<h2 id="AVCaptureConnection"><a href="#AVCaptureConnection" class="headerlink" title="AVCaptureConnection"></a>AVCaptureConnection</h2><p>连接输入源和输出端，可以有多个输入端，最后指定到输出源</p>
<p>#<strong>输出组件</strong></p>
<h2 id="AVCaptureOutput"><a href="#AVCaptureOutput" class="headerlink" title="AVCaptureOutput"></a>AVCaptureOutput</h2><p>一个定义输出规范的抽象类</p>
<h2 id="AVCaptureMovieFileOutput"><a href="#AVCaptureMovieFileOutput" class="headerlink" title="AVCaptureMovieFileOutput"></a>AVCaptureMovieFileOutput</h2><p>继承自AVCaptureOutput，以视频文件的形式输出</p>
<h2 id="AVCaptureVideoDataOutput"><a href="#AVCaptureVideoDataOutput" class="headerlink" title="AVCaptureVideoDataOutput"></a>AVCaptureVideoDataOutput</h2><p>继承自AVCaptureOutput，输出视频流数据</p>
<h2 id="AVCaptureAudioDataOutput"><a href="#AVCaptureAudioDataOutput" class="headerlink" title="AVCaptureAudioDataOutput"></a>AVCaptureAudioDataOutput</h2><p>继承自AVCaptureOutput, 输出音频流数据</p>
<h2 id="AVCaptureStillImageOutput"><a href="#AVCaptureStillImageOutput" class="headerlink" title="AVCaptureStillImageOutput"></a>AVCaptureStillImageOutput</h2><p>继承自AVCaptureOutput，以图片形式输出</p>
<h2 id="AVCaptureVideoPreviewLayer"><a href="#AVCaptureVideoPreviewLayer" class="headerlink" title="AVCaptureVideoPreviewLayer"></a>AVCaptureVideoPreviewLayer</h2><p>继承自CALayer，可以在录制的过程中提供一个预览给用户</p>
<h2 id="AVCaptureAudioChannel"><a href="#AVCaptureAudioChannel" class="headerlink" title="AVCaptureAudioChannel"></a>AVCaptureAudioChannel</h2><p>代表一个音频轨道，记录当前音轨的一些信息</p>
<p>整个对象关系如下图所示：</p>
<img src="/2019/08/20/AVFoundation-Capture/captureOverview_2x.png">

<img src="/2019/08/20/AVFoundation-Capture/captureDetail_2x.png">




      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AVFoundation-Edit" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/20/AVFoundation-Edit/" class="article-date">
  	<time datetime="2019-08-20T06:05:16.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/AVFoundation-Edit/">AVFoundation_Edit</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><h2 id="AVComposition"><a href="#AVComposition" class="headerlink" title="AVComposition"></a>AVComposition</h2><p>继承自 AVAsset，在视频编辑时用来表示保存音视频轨道的Container，一般使用其子类AVMutableComposition</p>
<h3 id="AVMutableComposition"><a href="#AVMutableComposition" class="headerlink" title="AVMutableComposition"></a>AVMutableComposition</h3><p>生成新视频的容器，从其他视频或者音频获取轨道，然后插入到当前容器中，如图所示：</p>
<img src="/2019/08/20/AVFoundation-Edit/avmutablecomposition_2x.png">

<h3 id="AVAudioMix-amp-amp-AVMutableAudioMix"><a href="#AVAudioMix-amp-amp-AVMutableAudioMix" class="headerlink" title="AVAudioMix &amp;&amp; AVMutableAudioMix"></a>AVAudioMix &amp;&amp; AVMutableAudioMix</h3><p>对音频轨道进行自定处理，一般使用其子类AVMutableAudioMix，通过接受参数的形式 inputParameters</p>
<h3 id="AVAudioMixInputParameters-amp-amp-AVMutableAudioMixInputParameters"><a href="#AVAudioMixInputParameters-amp-amp-AVMutableAudioMixInputParameters" class="headerlink" title="AVAudioMixInputParameters &amp;&amp; AVMutableAudioMixInputParameters"></a>AVAudioMixInputParameters &amp;&amp; AVMutableAudioMixInputParameters</h3><p>音频自定义处理参数对象，包含音量的调整和轨道信息以及音量算法</p>
<p>音频编辑对象关系如图所示:</p>
<img src="/2019/08/20/AVFoundation-Edit/avmutableaudiomix_2x.png">


<h3 id="AVVideoCompositing-amp-amp-AVMutableVideoComposition"><a href="#AVVideoCompositing-amp-amp-AVMutableVideoComposition" class="headerlink" title="AVVideoCompositing &amp;&amp; AVMutableVideoComposition"></a>AVVideoCompositing &amp;&amp; AVMutableVideoComposition</h3><p>视频合成器对象，可以通过该对象对视频进行自定义操作</p>
<h3 id="AVVideoCompositionInstruction-amp-amp-AVMutableVideoCompositionInstruction"><a href="#AVVideoCompositionInstruction-amp-amp-AVMutableVideoCompositionInstruction" class="headerlink" title="AVVideoCompositionInstruction &amp;&amp; AVMutableVideoCompositionInstruction"></a>AVVideoCompositionInstruction &amp;&amp; AVMutableVideoCompositionInstruction</h3><p>合成器的指令对象，该指令将会被合成器运用在视频合成中</p>
<h3 id="AVVideoCompositionLayerInstruction-amp-amp-AVMutableVideoCompositionLayerInstruction"><a href="#AVVideoCompositionLayerInstruction-amp-amp-AVMutableVideoCompositionLayerInstruction" class="headerlink" title="AVVideoCompositionLayerInstruction &amp;&amp; AVMutableVideoCompositionLayerInstruction"></a>AVVideoCompositionLayerInstruction &amp;&amp; AVMutableVideoCompositionLayerInstruction</h3><p>指令的参数对象，transform，opacity，cropping等参数的设置都会被作为指令合成到视频中</p>
<p>合成对象的关系如下图所示：</p>
<img src="/2019/08/20/AVFoundation-Edit/avmutablevideocomposition_2x.png">


<h2 id="视频导出"><a href="#视频导出" class="headerlink" title="视频导出"></a>视频导出</h2><h3 id="AVAssetExportSession"><a href="#AVAssetExportSession" class="headerlink" title="AVAssetExportSession"></a>AVAssetExportSession</h3><p>生成一个新的资源文件根据自定义的参数和AVAsset，结构如图所示：</p>
<img src="/2019/08/20/AVFoundation-Edit/puttingitalltogether_2x.png">







      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Video-Player" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/10/Video-Player/" class="article-date">
  	<time datetime="2018-12-10T04:15:14.000Z" itemprop="datePublished">2018-12-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/10/Video-Player/">Video_Player</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h1><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><ol>
<li><p>输入模块<br>输入: 本地磁盘媒体文件(FLV,MP4,AVI,MOV)或者网络媒体文件(HTTP,RTMP,HLS)<br>输入可能是不同的协议或者不同的数据格式,就需要涉及到格式解析和音视频数据拆分和解码,然后分别存储到音视频队列中</p>
</li>
<li><p>输出模块<br>输出: 扬声器播放视频中的音频, 屏幕显示视频画面<br>输出由2部分组成,分别是声音和视频,都需要从音视频队列中获取原始数据然后分别进行音视频的渲染</p>
</li>
<li><p>同步模块<br>同步模块: 同步声音和视频画 面<br>由于输入和输出分别处于2个模块中,并且是由2个线程控制. 在播放中就需要控制音视频的同步</p>
</li>
<li><p>调度器<br>将上面的几个模块组装起来，将输入模块和音视频队列封装到同步模块中,同步模块向外界提供数据接口,将输出模块,同步模块都封装到调度器中,这样输出模块可以向调度器要数据,调度器可以向输入模块要数据。</p>
</li>
</ol>
<p>设计的结构图如下:</p>
<img src="/2018/12/10/Video-Player/c.png">

<p>类图如下:</p>
<img src="/2018/12/10/Video-Player/d.png">

<p><strong>VideoPlayerController</strong>: 调度器,对外提供接口<br><strong>AudioOutput</strong>: 声音模块输出渲染<br><strong>VideoOutput</strong>: 视频模块输出渲染</p>
<p><strong>AVSynchronizer</strong>: 同步器,控制音视频同步<br><strong>VideoFrameQueue</strong>: 视频数据队列<br><strong>AudioFrameQueue</strong>: 音频数据队列</p>
<p><strong>VideoDecoder</strong>: 解码器,解析输入的格式和协议,拆分音视频原始数据<br><strong>VideoFrame</strong>: 视频数据封装对象<br><strong>AudioFrame</strong>: 音频数据封装对象</p>
<h3 id="模块方案"><a href="#模块方案" class="headerlink" title="模块方案"></a>模块方案</h3><ol>
<li><p>输入模块:<br>直接使用ffmpeg的libavforat来解析各种协议和不同的封装格式，解码操作直接使用libavcodec来实现(更高效的应该使用各自平台的硬件解码)</p>
</li>
<li><p>输出模块:</p>
</li>
</ol>
<p><strong>音频</strong>:<br>android: 产用的是AudioTrack和OpenSl ES, OpenSl ES提供延迟更低,节省JNI数据传输。<br>iOS: AudioQueue或者AudioUnit。AudioQueue是封装的AudioUnit,采取AudioUnit能够更加自定义<br><strong>视频</strong>:<br>使用 OpenGL ES 跨平台渲染, android 输出到 SurfaceView, iOS 输出到 UIView.</p>
<ol start="3">
<li>同步模块:<br>使用2个平台都支持的 pthread, 自己编写链表实现队列, 然后采用视频向音频对其的方式同步画面</li>
</ol>
<h2 id="架构风险评估"><a href="#架构风险评估" class="headerlink" title="架构风险评估"></a>架构风险评估</h2><ol>
<li>兼容性设计</li>
<li>性能问题</li>
</ol>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><ol>
<li>输入协议</li>
<li>编码格式</li>
<li>音视频同步</li>
<li>兼容性</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-DLNA" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/20/DLNA/" class="article-date">
  	<time datetime="2018-08-20T02:45:14.000Z" itemprop="datePublished">2018-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/20/DLNA/">DLNA</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="DLNA"><a href="#DLNA" class="headerlink" title="DLNA"></a>DLNA</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="DLNA-1"><a href="#DLNA-1" class="headerlink" title="DLNA"></a>DLNA</h3><p>DLNA (Digital Living Network Alliance，是一种让设备在有线或无线网络间互通的标准，它包含多种其他协议和其他标准，较的是UPnP.</p>
<p>详细的DLNA介绍可参见<a href="https://eliyar.biz/DLNA_with_iOS_Android/" target="_blank" rel="noopener">DLNA基本概念</a>, <a href="http://dlna.org" target="_blank" rel="noopener">DLNA官网</a></p>
<h3 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h3><p>UPnP(Universal Plug and Play), 是一套多层协议构成的框架体系，来简化设备间的连接和控制的协议。</p>
<p>详细的UPnP介绍可参见<a href="http://blog.csdn.net/braddoris/article/details/41646789" target="_blank" rel="noopener">UPnP简介一</a>,<a href="http://blog.csdn.net/braddoris/article/details/41646809" target="_blank" rel="noopener">UPnP简介二</a></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>UPnP 技术是架构在 IP 网络之上。因此拥有一个网络中唯一的 IP 地址是 UPnP 设备正常工作的基础。UPnP 设备首先查看网络中是否有 DHCP 服务器，如果有，那么使用 DHCP 分配的 IP 即可；如果没有，则需要使用LLA技术来为自己找适合的IP地址, 在 UPnP 运行过程中，UPnP 设备都需要周期性检测网络中是否有 DHCP 服务器存在，一旦发现有 DHCP 服务器，就必须终止使用 LLA 技术获取的 IP 地址，改用 DHCP 分配的 IP 地址。</p>
<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>使用SSDP(Simple Sever Discovery Protocol), 简单服务发现协议发现设备，此协议采用基于通知和发现路由的多播发现方式实现。协议客户端在保留的多播地址：239.255.255.250：1900（IPV4）,（IPv6 是：FF0x::C）同时每个设备服务也在此地址上上监听服务发现请求。如果服务监听到的发现请求与此服务相匹配，此服务会使用单播方式响应。</p>
<p>SSDP ，发现的方式有2种:</p>
<h5 id="1-主动通知方式："><a href="#1-主动通知方式：" class="headerlink" title="1.主动通知方式："></a>1.主动通知方式：</h5><p>当设备加入到网络中，向网络上所有控制点通知它所提供的服务，通知消息采用多播方式。</p>
<p>当设备添加到网络后，定期向（239.255.255.250:1900）发送SSDP通知消息宣告自己的设备和服务<br>宣告消息分为 <strong>ssdp:alive(设备可用)</strong> 和 <strong>ssdp:byebye(设备不可用)</strong></p>
<p><strong>ssdp:alive 消息</strong></p>
<pre><code>NOTIFY * HTTP/1.1           // 消息头
NT:                         // 在此消息中，NT头必须为服务的服务类型。（如：upnp:rootdevice）
HOST:                       // 设置为协议保留多播地址和端口，必须是：239.255.255.250:1900（IPv4）或FF0x::C(IPv6
NTS:                        // 表示通知消息的子类型，必须为ssdp:alive
LOCATION:                   // 包含根设备描述得URL地址  device 的webservice路径（如：http://127.0.0.1:2351/1.xml) 
CACHE-CONTROL:              // max-age指定通知消息存活时间，如果超过此时间间隔，控制点可以认为设备不存在 （如：max-age=1800）
SERVER:                     // 包含操作系统名，版本，产品名和产品版本信息( 如：Windows NT/5.0, UPnP/1.0)
USN:                        // 表示不同服务的统一服务名，它提供了一种标识出相同类型服务的能力。如：
                            // 根/启动设备 uuid:f7001351-cf4f-4edd-b3df-4b04792d0e8a::upnp:rootdevice
                            // 连接管理器  uuid:f7001351-cf4f-4edd-b3df-4b04792d0e8a::urn:schemas-upnp-org:service:ConnectionManager:1
                            // 内容管理器 uuid:f7001351-cf4f-4edd-b3df-4b04792d0e8a::urn:schemas-upnp-org:service:ContentDirectory:1</code></pre><p><strong>ssdp:byebye(设备不可用)</strong></p>
<pre><code>NOTIFY * HTTP/1.1       // 消息头
HOST:                   // 设置为协议保留多播地址和端口，必须是：239.255.255.250:1900（IPv4）或FF0x::C(IPv6
NTS:                    // 表示通知消息的子类型，必须为ssdp:byebye
USN:                    // 同上</code></pre><h5 id="2-搜索——响应方式："><a href="#2-搜索——响应方式：" class="headerlink" title="2. 搜索——响应方式："></a>2. 搜索——响应方式：</h5><p>当一个控制点加入到网络中，在网络搜索它感兴趣的所有设备和服务，搜索消息采用多播方式发送，而设备针对搜索的响应则是使用单播方式发送。</p>
<p>多播搜索消息如下：</p>
<pre><code>M-SEARCH * HTTP/1.1             // 请求头 不可改变
MAN: &quot;ssdp:discover&quot;            // 设置协议查询的类型，必须是：ssdp:discover
MX: 5                           // 设置设备响应最长等待时间，设备响应在0和这个值之间随机选择响应延迟的值。这样可以为控制点响应平衡网络负载。
HOST: 239.255.255.250:1900      // 设置为协议保留多播地址和端口，必须是：239.255.255.250:1900（IPv4）或FF0x::C(IPv6
ST: upnp:rootdevice             // 设置服务查询的目标，它必须是下面的类型：
                                // ssdp:all  搜索所有设备和服务 
                                // upnp:rootdevice  仅搜索网络中的根设备 
                                // uuid:device-UUID  查询UUID标识的设备 
                                // urn:schemas-upnp-org:device:device-Type:version  查询device-Type字段指定的设备类型，设备类型和版本由UPNP组织定义。 
                                // urn:schemas-upnp-org:service:service-Type:version  查询service-Type字段指定的服务类型，服务类型和版本由UPNP组织定义。                                    </code></pre><p><strong>如果需要实现投屏，则设备类型 ST 为 urn:schemas-upnp-org:service:AVTransport:1</strong></p>
<p>多播搜索响应消息如下:</p>
<pre><code>HTTP/1.1 200 OK             // * 消息头
LOCATION:                   // * 包含根设备描述得URL地址  device 的webservice路径（如：http://127.0.0.1:2351/1.xml) 
CACHE-CONTROL:              // * max-age指定通知消息存活时间，如果超过此时间间隔，控制点可以认为设备不存在 （如：max-age=1800）
SERVER:                     // 包含操作系统名，版本，产品名和产品版本信息( 如：Windows NT/5.0, UPnP/1.0)
EXT:                        // 为了符合HTTP协议要求，并未使用。
BOOTID.UPNP.ORG:            // 可以不存在，初始值为时间戳，每当设备重启并加入到网络时+1，用于判断设备是否重启。也可以用于区分多宿主设备。
CONFIGID.UPNP.ORG:          // 可以不存在，由两部分组成的非负十六进制整数，由两部分组成，第一部分代表跟设备和其上的嵌入式设备，第二部分代表这些设备上的服务。
USN:                        // * 表示不同服务的统一服务名
ST:                         // * 服务的服务类型
DATE:                       // 响应生成时间</code></pre><p>多播搜索响应消息的Response:</p>
<pre><code>HTTP/1.1 200 OK
Cache-control: max-age=1800
Usn: uuid:88024158-a0e8-2dd5-ffff-ffffc7831a22::urn:schemas-upnp-org:service:AVTransport:1
Location: http://192.168.1.243:46201/dev/88024158-a0e8-2dd5-ffff-ffffc7831a22/desc.xml
Server: Linux/3.10.33 UPnP/1.0 Teleal-Cling/1.0
Date: Tue, 01 Mar 2016 08:47:42 GMT+00:00
Ext: 
St: urn:schemas-upnp-org:service:AVTransport:1</code></pre><p><strong>PS 有些设备返回来的字段名称可能包含有小写，如LOCATION和Location，需要做处理</strong></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>搜索到设备以后,还不知道设备的详细信息和提供的服务信息,此时就需要获取描述文档，描述文档分为两种类型，</p>
<h4 id="1-DDD-设备描述文档"><a href="#1-DDD-设备描述文档" class="headerlink" title="1. DDD(设备描述文档)"></a>1. DDD(设备描述文档)</h4><p>通过HTTP GET拿到相关信息,链接为多播搜索响应消息返回的Location字段指向的地址，该文档的XML包含相关的设备信息和服务信息</p>
<pre><code>GET http://192.168.1.243:46201/dev/88024158-a0e8-2dd5-ffff-ffffc7831a22/desc.xml

返回的XML格式为：
HTTP/1.1 200 OK
Content-Length    : 3612
Content-type      : text/xml
Date              : Tue, 01 Mar 2016 10:00:36 GMT+00:00
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot; xmlns:qq=&quot;http://www.tencent.com&quot;&gt;
    &lt;specVersion&gt;
        &lt;major&gt;1&lt;/major&gt;
        &lt;minor&gt;0&lt;/minor&gt;
    &lt;/specVersion&gt;
    &lt;device&gt;
        &lt;deviceType&gt;urn:schemas-upnp-org:device:MediaRenderer:1&lt;/deviceType&gt;
        &lt;UDN&gt;uuid:88024158-a0e8-2dd5-ffff-ffffc7831a22&lt;/UDN&gt;
        &lt;friendlyName&gt;客厅的小米盒子&lt;/friendlyName&gt;
        &lt;qq:X_QPlay_SoftwareCapability&gt;QPlay:1&lt;/qq:X_QPlay_SoftwareCapability&gt;
        &lt;manufacturer&gt;Xiaomi&lt;/manufacturer&gt;
        &lt;manufacturerURL&gt;http://www.xiaomi.com/&lt;/manufacturerURL&gt;
        &lt;modelDescription&gt;Xiaomi MediaRenderer&lt;/modelDescription&gt;
        &lt;modelName&gt;Xiaomi MediaRenderer&lt;/modelName&gt;
        &lt;modelNumber&gt;1&lt;/modelNumber&gt;
        &lt;modelURL&gt;http://www.xiaomi.com/hezi&lt;/modelURL&gt;
        &lt;serialNumber&gt;11262/180303452&lt;/serialNumber&gt;
        &lt;presentationURL&gt;device_presentation_page.html&lt;/presentationURL&gt;
        &lt;UPC&gt;123456789012&lt;/UPC&gt;
        &lt;dlna:X_DLNADOC xmlns:dlna=&quot;urn:schemas-dlna-org:device-1-0&quot;&gt;DMR-1.50&lt;/dlna:X_DLNADOC&gt;
        &lt;dlna:X_DLNACAP xmlns:dlna=&quot;urn:schemas-dlna-org:device-1-0&quot;&gt;,&lt;/dlna:X_DLNACAP&gt;
        &lt;iconList&gt;
            &lt;icon&gt;
                &lt;mimetype&gt;image/png&lt;/mimetype&gt;
                &lt;width&gt;128&lt;/width&gt;
                &lt;height&gt;128&lt;/height&gt;
                &lt;depth&gt;8&lt;/depth&gt;
                &lt;url&gt;icon/icon128x128.png&lt;/url&gt;
            &lt;/icon&gt;
        &lt;/iconList&gt;
        &lt;serviceList&gt;
            &lt;service&gt;
                &lt;serviceType&gt;urn:schemas-upnp-org:service:AVTransport:1&lt;/serviceType&gt;
                &lt;serviceId&gt;urn:upnp-org:serviceId:AVTransport&lt;/serviceId&gt;
                &lt;controlURL&gt;/dev/88024158-a0e8-2dd5-ffff-ffffc7831a22/svc/upnp-org/AVTransport/action&lt;/controlURL&gt;
                &lt;eventSubURL&gt;/dev/88024158-a0e8-2dd5-ffff-ffffc7831a22/svc/upnp-org/AVTransport/event&lt;/eventSubURL&gt;
                &lt;SCPDURL&gt;/dev/88024158-a0e8-2dd5-ffff-ffffc7831a22/svc/upnp-org/AVTransport/desc.xml&lt;/SCPDURL&gt;
            &lt;/service&gt;
        &lt;/serviceList&gt;
        &lt;av:X_RController_DeviceInfo xmlns:av=&quot;urn:mi-com:av&quot;&gt;
            &lt;av:X_RController_Version&gt;1.0&lt;/av:X_RController_Version&gt;
            &lt;av:X_RController_ServiceList&gt;
                &lt;av:X_RController_Service&gt;
                    &lt;av:X_RController_ServiceType&gt;controller&lt;/av:X_RController_ServiceType&gt;
                    &lt;av:X_RController_ActionList_URL&gt;http://192.168.1.243:6095/&lt;/av:X_RController_ActionList_URL&gt;
                &lt;/av:X_RController_Service&gt;
                &lt;av:X_RController_Service&gt;
                    &lt;av:X_RController_ServiceType&gt;data&lt;/av:X_RController_ServiceType&gt;
                    &lt;av:X_RController_ActionList_URL&gt;http://api.tv.duokanbox.com/bolt/3party/&lt;/av:X_RController_ActionList_URL&gt;
                &lt;/av:X_RController_Service&gt;
            &lt;/av:X_RController_ServiceList&gt;
        &lt;/av:X_RController_DeviceInfo&gt;
    &lt;/device&gt;
&lt;/root&gt;</code></pre><h4 id="2-SDD-服务描述文档"><a href="#2-SDD-服务描述文档" class="headerlink" title="2. SDD(服务描述文档)"></a>2. SDD(服务描述文档)</h4><p>通过HTTP GET拿到服务描述文档, 链接为DDD中获取到的当前设备提供的服务指向的XML的节点SCPDURL地址，返回的服务描述文档中包含了相关的服务具体描述</p>
<pre><code>GET http://192.168.1.243:46201/dev/88024158-a0e8-2dd5-ffff-ffffc7831a22/svc/upnp-org/AVTransport/desc.xml

//返回的XML如下：
HTTP/1.1 200 OK
Content-Length    : 3612
Content-type      : text/xml
Date              : Tue, 01 Mar 2016 10:00:36 GMT+00:00
&lt;!-- 省略了部分动作和状态变量 --&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;scpd xmlns=&quot;urn:schemas-upnp-org:service-1-0&quot;&gt;
    &lt;specVersion&gt;
        &lt;major&gt;1&lt;/major&gt;
        &lt;minor&gt;0&lt;/minor&gt;
    &lt;/specVersion&gt;
    &lt;actionList&gt;
        &lt;action&gt;
            &lt;name&gt;Pause&lt;/name&gt;
            &lt;argumentList&gt;
                &lt;argument&gt;
                    &lt;name&gt;InstanceID&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;A_ARG_TYPE_InstanceID&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
            &lt;/argumentList&gt;
        &lt;/action&gt;
        &lt;action&gt;
            &lt;name&gt;Play&lt;/name&gt;
            &lt;argumentList&gt;
                &lt;argument&gt;
                    &lt;name&gt;InstanceID&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;A_ARG_TYPE_InstanceID&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
                &lt;argument&gt;
                    &lt;name&gt;Speed&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;TransportPlaySpeed&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
            &lt;/argumentList&gt;
        &lt;/action&gt;
        &lt;action&gt;
            &lt;name&gt;Previous&lt;/name&gt;
            &lt;argumentList&gt;
                &lt;argument&gt;
                    &lt;name&gt;InstanceID&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;A_ARG_TYPE_InstanceID&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
            &lt;/argumentList&gt;
        &lt;/action&gt;
        &lt;action&gt;
            &lt;name&gt;SetAVTransportURI&lt;/name&gt;
            &lt;argumentList&gt;
                &lt;argument&gt;
                    &lt;name&gt;InstanceID&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;A_ARG_TYPE_InstanceID&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
                &lt;argument&gt;
                    &lt;name&gt;CurrentURI&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;AVTransportURI&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
                &lt;argument&gt;
                    &lt;name&gt;CurrentURIMetaData&lt;/name&gt;
                    &lt;direction&gt;in&lt;/direction&gt;
                    &lt;relatedStateVariable&gt;AVTransportURIMetaData&lt;/relatedStateVariable&gt;
                &lt;/argument&gt;
            &lt;/argumentList&gt;
        &lt;/action&gt;
        ...
    &lt;/actionList&gt;
    &lt;serviceStateTable&gt;
        &lt;stateVariable sendEvents=&quot;no&quot;&gt;
            &lt;name&gt;CurrentTrackURI&lt;/name&gt;
            &lt;dataType&gt;string&lt;/dataType&gt;
        &lt;/stateVariable&gt;
        &lt;stateVariable sendEvents=&quot;no&quot;&gt;
            &lt;name&gt;CurrentMediaDuration&lt;/name&gt;
            &lt;dataType&gt;string&lt;/dataType&gt;
        &lt;/stateVariable&gt;
        &lt;stateVariable sendEvents=&quot;no&quot;&gt;
            &lt;name&gt;AbsoluteCounterPosition&lt;/name&gt;
            &lt;dataType&gt;i4&lt;/dataType&gt;
        &lt;/stateVariable&gt;
        &lt;stateVariable sendEvents=&quot;no&quot;&gt;
            &lt;name&gt;RelativeCounterPosition&lt;/name&gt;
            &lt;dataType&gt;i4&lt;/dataType&gt;
        &lt;/stateVariable&gt;
        &lt;stateVariable sendEvents=&quot;no&quot;&gt;
            &lt;name&gt;A_ARG_TYPE_InstanceID&lt;/name&gt;
            &lt;dataType&gt;ui4&lt;/dataType&gt;
        &lt;/stateVariable&gt;
        ...
    &lt;/serviceStateTable&gt;
&lt;/scpd&gt;</code></pre><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>控制点和服务之间使用简单对象访问协议（Simple Object Access Protocol，SOAP）的格式，在 UPnP 中，把 SOAP 控制/响应信息分成 3 种： UPnP Action Request、UPnP Action Response-Success 和 UPnP Action Response-Error</p>
<h4 id="1-UPnP-Action-Request"><a href="#1-UPnP-Action-Request" class="headerlink" title="1.UPnP Action Request"></a>1.UPnP Action Request</h4><p>使用Post发送控制消息</p>
<pre><code>POST &lt;control URL&gt; HTTP/1.0
Host: hostname:portNumber
Content-Lenght: byte in body
Content-Type: text/xml; charset=&quot;utf-8&quot;
SOAPACTION: &quot;urn:schemas-upnp-org:service:serviceType:v#actionName&quot;
&lt;!--必有字段--&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!--SOAP必有字段--&gt;
&lt;s:Envelope s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
    &lt;s:Body&gt;
        &lt;!--Body内部分根据不同动作不同--&gt;
        &lt;!--动作名称--&gt;
        &lt;u:actionName xmlns:u=&quot;urn:schemas-upnp-org:service:serviceType:v&quot;&gt;
            &lt;!--输入参数名称和值--&gt;
            &lt;argumentName&gt;in arg values&lt;/argumentName&gt;
             &lt;!--若有多个参数则需要提供--&gt;
        &lt;/u:actionName&gt;
    &lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><h4 id="2-UPnP-Action-Response-Success"><a href="#2-UPnP-Action-Response-Success" class="headerlink" title="2.UPnP Action Response-Success"></a>2.UPnP Action Response-Success</h4><p>收到控制点发来的动作调用请求后，设备上的服务必须执行动作调用。，并在 30s 内响应。如果需要超过 30s 才能完成执行的动作，则可以先返回一个应答消息，等动作执行完成再利用事件机制返回动作响应。</p>
<pre><code>HTTP/1.0 200 OK                             // 响应成功响应头
Content-Type: text/xml; charset=&quot;utf-8&quot;
Date: Tue, 01 Mar 2016 10:00:36 GMT+00:00
Content-Length: byte in body
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;
&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
    &lt;s:Body&gt;
        &lt;!--之前部分为固定字段--&gt;
        &lt;!--之前部分为固定字段--&gt;
        &lt;u:actionNameResponse xmlns:u=&quot;urn:schemas-upnp-org:service:serviceType:v&quot;&gt;
            &lt;!--输出变量名称和值--&gt;
            &lt;arugumentName&gt;out arg value&lt;/arugumentName&gt;
            &lt;!--若有多个输出变量则继续写，没有可以不存在输出变量--&gt;
        &lt;/u:actionNameResponse&gt;
    &lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><h4 id="3-UPnP-Action-Response-Error"><a href="#3-UPnP-Action-Response-Error" class="headerlink" title="3.UPnP Action Response-Error"></a>3.UPnP Action Response-Error</h4><p>如果处理动作过程中出现错误，则返回一个一下格式的错误响应。</p>
<pre><code>HTTP/1.0 500 Internal Server Error          // 响应成功响应头
Content-Type: text/xml; charset=&quot;utf-8&quot;
Date: Tue, 01 Mar 2016 10:00:36 GMT+00:00
Content-Length: byte in body
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;
&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;
    &lt;s:Body&gt;
        &lt;u:Fault&gt;
            &lt;!--之前部分为固定字段--&gt;
            &lt;faultcode&gt;s:Client&lt;/faultcode&gt;
            &lt;faultstring&gt;UPnPError&lt;/faultstring&gt;
            &lt;detail&gt;
                &lt;UPnPError xmlns=&quot;urn:schemas-upnp-org:control-1-0&quot;&gt;
                    &lt;errorCode&gt;402&lt;/errorCode&gt;
                    &lt;errorDescription&gt;Invalid or Missing Args&lt;/errorDescription&gt;
                &lt;/UPnPError&gt;
            &lt;/detail&gt;
        &lt;/u:actionNameResponse&gt;
    &lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>略，详细可参考<a href="https://eliyar.biz/DLNA_with_iOS_Android_Part_3_Subscribe_Event/" target="_blank" rel="noopener">订阅事件通知</a></p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2018/08/20/DLNA/DLNA.png">

<h2 id="iOS实现"><a href="#iOS实现" class="headerlink" title="iOS实现"></a>iOS实现</h2><p>参见<a href="https://github.com/ClaudeLi/DLNA_UPnP" target="_blank" rel="noopener">DEMO</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-MP3-LAME" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/10/MP3-LAME/" class="article-date">
  	<time datetime="2018-08-10T04:15:14.000Z" itemprop="datePublished">2018-08-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/10/MP3-LAME/">MP3_LAME</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS-使用LAME编码MP3文件"><a href="#iOS-使用LAME编码MP3文件" class="headerlink" title="iOS 使用LAME编码MP3文件"></a>iOS 使用LAME编码MP3文件</h1><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><p>将音频原始数据为PCM格式编码成可以直接播放的Mp3文件的过程,该过程使用LAME</p>
<h2 id="LAME"><a href="#LAME" class="headerlink" title="LAME"></a>LAME</h2><h3 id="LAME是做什么的？"><a href="#LAME是做什么的？" class="headerlink" title="LAME是做什么的？"></a>LAME是做什么的？</h3><p>LAME是目前非常优秀的一种MP3编码引擎，在业界，转码成MP3格式的音频文件时，最常用的编码器就是LAME库</p>
<h2 id="编译LAME"><a href="#编译LAME" class="headerlink" title="编译LAME"></a>编译LAME</h2><h3 id="下载：-https-sourceforge-net-projects-lame-files-lame"><a href="#下载：-https-sourceforge-net-projects-lame-files-lame" class="headerlink" title="下载： https://sourceforge.net/projects/lame/files/lame/"></a>下载： <a href="https://sourceforge.net/projects/lame/files/lame/" target="_blank" rel="noopener">https://sourceforge.net/projects/lame/files/lame/</a></h3><h3 id="下载编译脚本：-https-github-com-kewlbear-lame-ios-build"><a href="#下载编译脚本：-https-github-com-kewlbear-lame-ios-build" class="headerlink" title="下载编译脚本： https://github.com/kewlbear/lame-ios-build"></a>下载编译脚本： <a href="https://github.com/kewlbear/lame-ios-build" target="_blank" rel="noopener">https://github.com/kewlbear/lame-ios-build</a></h3><h3 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h3><ol>
<li>将下载的文件放入同一个文件夹</li>
<li>修改 build-lame.sh 的 SOURCE=”xxx”, XXX为lame解压后的文件夹名字</li>
<li>终端命令行执行 ./build-lame.sh</li>
<li>命令行执行完成后, fat-lame 就是编译好的文件所在</li>
</ol>
<h2 id="新建iOS工程"><a href="#新建iOS工程" class="headerlink" title="新建iOS工程"></a>新建iOS工程</h2><ol>
<li>打开Xcode, 创建一个工程命名为Mp3Encoder</li>
<li>添加编译得到的 fat-lame 库</li>
<li>下载原始的PCM测试文件,添加到工程中,<a href="https://gitee.com/xiansanyee/codes/saix3etdh0bywm4pr9gzl38" target="_blank" rel="noopener">https://gitee.com/xiansanyee/codes/saix3etdh0bywm4pr9gzl38</a></li>
<li>新建C++文件,命名为mp3_encoder</li>
</ol>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的:"></a>目的:</h3><p>输入一个原始的pcm文件，然后经过LAME转换为mp3文件</p>
<h3 id="mp3-encoder头文件"><a href="#mp3-encoder头文件" class="headerlink" title="mp3_encoder头文件"></a>mp3_encoder头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Mp3Encoder&#123;</span><br><span class="line">private:</span><br><span class="line">    FILE *pcmFile;</span><br><span class="line">    FILE *mp3File;</span><br><span class="line">    lame_t lameClient;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    Mp3Encoder();</span><br><span class="line">    ~Mp3Encoder();</span><br><span class="line">    int Init(const char * pcmFilePath, const char *mp3FilePath, int sampleRate, int channels, int bitRate);</span><br><span class="line">    void Encode();</span><br><span class="line">    void Destory();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="mp3-encoder实现文件"><a href="#mp3-encoder实现文件" class="headerlink" title="mp3_encoder实现文件"></a>mp3_encoder实现文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Mp3Encoder::Mp3Encoder()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mp3Encoder::~Mp3Encoder()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Mp3Encoder::Init(<span class="keyword">const</span> <span class="keyword">char</span> *pcmFilePath, <span class="keyword">const</span> <span class="keyword">char</span> *mp3FilePath, <span class="keyword">int</span> sampleRate, <span class="keyword">int</span> channels, <span class="keyword">int</span> bitRate)&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    pcmFile = fopen(pcmFilePath, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pcmFile) &#123;</span><br><span class="line">        mp3File = fopen(mp3FilePath, <span class="string">"wb"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mp3File) &#123;</span><br><span class="line">            lameClient = lame_init();</span><br><span class="line">            lame_set_in_samplerate(lameClient, sampleRate);</span><br><span class="line">            lame_set_out_samplerate(lameClient, sampleRate);</span><br><span class="line">            lame_set_num_channels(lameClient, channels);</span><br><span class="line">            lame_set_brate(lameClient, bitRate / <span class="number">1000</span>);</span><br><span class="line">            lame_init_params(lameClient);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mp3Encoder::Encode()&#123;</span><br><span class="line">    <span class="keyword">int</span> bufferSize = <span class="number">1024</span> * <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">short</span> *buffer = <span class="keyword">new</span> <span class="keyword">short</span>[bufferSize / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">short</span> *leftBuffer = <span class="keyword">new</span> <span class="keyword">short</span>[bufferSize / <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">short</span> *rightBuffer = <span class="keyword">new</span> <span class="keyword">short</span>[bufferSize / <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *mp3_buffer = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[bufferSize];</span><br><span class="line">    <span class="keyword">size_t</span> readBufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((readBufferSize = fread(buffer, <span class="number">2</span>, bufferSize / <span class="number">2</span>, pcmFile)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; readBufferSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                leftBuffer[i / <span class="number">2</span>] = buffer[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rightBuffer[i / <span class="number">2</span>] = buffer[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">size_t</span> wroteSize = lame_encode_buffer(lameClient, leftBuffer, rightBuffer, (<span class="keyword">int</span>)(readBufferSize / <span class="number">2</span>), mp3_buffer, bufferSize);</span><br><span class="line">        fwrite(mp3_buffer, <span class="number">1</span>, wroteSize, mp3File);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="keyword">delete</span>[] leftBuffer;</span><br><span class="line">    <span class="keyword">delete</span>[] rightBuffer;</span><br><span class="line">    <span class="keyword">delete</span>[] mp3_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mp3Encoder::Destory()&#123;</span><br><span class="line">    <span class="keyword">if</span> (pcmFile) &#123;</span><br><span class="line">        fclose(pcmFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mp3File) &#123;</span><br><span class="line">        fclose(mp3File);</span><br><span class="line">        lame_close(lameClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li><p>Main.storyboard中添加一个按钮,链接点击时间到ViewController中</p>
<pre><code>- (IBAction)startEncode:(id)sender</code></pre></li>
<li><p>初始化Mp3Encoder并调用进行解码</p>
<pre><code>NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;start&quot;);
NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;pcm&quot;];
NSString *desFolder = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];

NSString *desPath = [desFolder stringByAppendingPathComponent:@&quot;test.mp3&quot;];

const char *sp = [sourcePath cStringUsingEncoding:NSUTF8StringEncoding];
const char *dp = [desPath cStringUsingEncoding:NSUTF8StringEncoding];
Mp3Encoder *encoder = new Mp3Encoder();
__unused int ret = encoder-&gt;Init(sp, dp, 44100, 2, 128 * 1240);
encoder-&gt;Encode();
encoder-&gt;Destory();
NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;finished&quot;);    </code></pre></li>
<li><p>配置C++编译支持<br>在Xcode中,target的build-seting中，other linker flags 添加 -lstdc++<br>修改ViewController.m为ViewController.mm</p>
</li>
<li><p>配置应用程序证书,运行,并点击按钮调用方法开始编码</p>
</li>
<li><p>使用Xcode-&gt;Window-&gt;Devices and Simulators, 选中应用程序, 导致AppData</p>
</li>
<li><p>展开AppData，找到编码好的mp3文件, 测试播放</p>
</li>
</ol>
<h2 id="其它常用库编译"><a href="#其它常用库编译" class="headerlink" title="其它常用库编译"></a>其它常用库编译</h2><p><strong>buid fdk-acc</strong></p>
<ol>
<li>download fdk-acc by ‘git clone <a href="https://git.code.sf.net/p/opencore-amr/fdk-aac" target="_blank" rel="noopener">https://git.code.sf.net/p/opencore-amr/fdk-aac</a> opencore-amr-fdk-aac’</li>
<li>download build script by ‘git clone <a href="https://github.com/kewlbear/fdk-aac-build-script-for-iOS&#39;" target="_blank" rel="noopener">https://github.com/kewlbear/fdk-aac-build-script-for-iOS&#39;</a></li>
<li>modify build-fdk-acc.sh, let SOURCE=”xxx” ,xxx is the name of fdk-acc foler</li>
<li>cd xxx, user terminal input ‘autoreconf -i’,and press enter</li>
<li>cd ..</li>
<li>./build-fdk-aac.sh</li>
</ol>
<p><strong>x264</strong></p>
<ol>
<li>git clone <a href="http://git.videolan.org/git/x264.git" target="_blank" rel="noopener">http://git.videolan.org/git/x264.git</a></li>
<li><a href="https://github.com/kewlbear/x264-ios.git" target="_blank" rel="noopener">https://github.com/kewlbear/x264-ios.git</a></li>
<li>build same with lame and fdk-acc</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Alex Wu
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>